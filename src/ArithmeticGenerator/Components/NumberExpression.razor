@using ArithmeticGenerator.Models
@using ArithmeticGenerator.QuestionBuilder

<style>
    .my-custom-class {
        backdrop-filter: blur(10px);
    }

    .custom-striped {
        background: repeating-linear-gradient( 45deg, #009688, #009688 10px, #00675B 10px, #00675B 20px );
        color: white !important;
    }
</style>

<NumberSelector NumberChanged="@OnNumber1Changed"></NumberSelector>
<MudToggleGroup @bind-Value="Operator"
                T="OperatorEnum"
                Class="my-2"
                Size="Size.Small"
                SelectedClass="@ToggleStyle"
                Style="width: 10rem">
    <MudToggleItem Value="@(OperatorEnum.Add)" Text="@(OperatorEnum.Add.GetDescription())" />
    <MudToggleItem Value="@(OperatorEnum.Subtract)" Text="@(OperatorEnum.Subtract.GetDescription())" />
    <MudToggleItem Value="@(OperatorEnum.Multiply)" Text="@(OperatorEnum.Multiply.GetDescription())" />
    <MudToggleItem Value="@(OperatorEnum.Divide)" Text="@(OperatorEnum.Divide.GetDescription())" />
</MudToggleGroup>

<NumberSelector NumberChanged="@OnNumber2Changed"></NumberSelector>

<div class="d-flex align-center mt-2">
    <MudText Typo="Typo.subtitle2">结果约束</MudText>
    <MudChipSet @bind-SelectedValues="ResultRules"
                T="ResultRuleEnum"
                Class="ml-2"
                SelectionMode="SelectionMode.MultiSelection"
                CheckMark="true"
                Variant="Variant.Filled"
                Color="Color.Primary">
        @if (Operator == OperatorEnum.Subtract)
        {
            <MudChip Value="@(ResultRuleEnum.GreaterThanZero)" Text="@(ResultRuleEnum.GreaterThanZero.GetDescription())" />
        }
        @if (Operator == OperatorEnum.Multiply)
        {
            <MudChip Value="@(ResultRuleEnum.IsNotOne)" Text="@(ResultRuleEnum.IsNotOne.GetDescription())" />
        }
        @if (Operator == OperatorEnum.Divide)
        {
            <MudChip Value="@(ResultRuleEnum.IsInt)" Text="@(ResultRuleEnum.IsInt.GetDescription())" />
            <MudChip Value="@(ResultRuleEnum.IsNotOne)" Text="@(ResultRuleEnum.IsNotOne.GetDescription())" />
        }
    </MudChipSet>

    <MudChip T="string" Class="ml-8" Color="Color.Primary" Disabled="true">@($"示例：{_numberValue}")</MudChip>
</div>

<MudButton Variant="Variant.Filled"
           StartIcon="@Icons.Material.Filled.Save"
           Color="Color.Primary"
           Size="Size.Small"
           Class="mt-4"
           OnClick="AddNumberExpression">添加题型</MudButton>

@code {
    private const string ToggleStyle = "custom-striped";

    private OperatorEnum _operator2;
    public OperatorEnum Operator
    {
        get => _operator2;
        set
        {
            _operator2 = value;
            CreateNumberExpression();
        }
    }
    private ResultRuleEnum _resultRule;
    private IReadOnlyCollection<ResultRuleEnum> _resultRules = null!;
    public IReadOnlyCollection<ResultRuleEnum> ResultRules
    {
        get => _resultRules;
        set
        {
            _resultRules = value;
            _resultRule = CombineRules(_resultRules);
        }
    }

    private CustomNumber? _number1;
    private CustomNumber? _number2;

    private string _numberValue = "";


    [Parameter]
    public EventCallback<DisplayExpression> ExpressionSelected { get; set; }

    [Inject]
    private QuestionFactory QuestionFactory { get; set; } = default!;

    protected override void OnInitialized()
    {
        Operator = OperatorEnum.Add;
        base.OnInitialized();
    }

    private void OnNumber1Changed(CustomNumber number)
    {
        _number1 = number;
        CreateNumberExpression();
    }
    private void OnNumber2Changed(CustomNumber number)
    {
        _number2 = number;
        CreateNumberExpression();
    }

    private void CreateNumberExpression()
    {
        _numberValue = "";
        if (_number1 != null && _number2 != null)
        {
            _numberValue = QuestionFactory.Create(Operator, _number1, _number2).GenerateQuestion(_resultRule);
        }
    }

    public static ResultRuleEnum CombineRules(IReadOnlyCollection<ResultRuleEnum> rules)
    {
        ResultRuleEnum combinedRule = 0;
        foreach (var rule in rules)
        {
            combinedRule |= rule;
        }
        return combinedRule;
    }

    private async Task AddNumberExpression()
    {
        if (_number1 == null || _number2 == null)
        {
            return;
        }
        await ExpressionSelected.InvokeAsync(new DisplayExpression(_number1, Operator, _number2, _resultRule));
    }
}
